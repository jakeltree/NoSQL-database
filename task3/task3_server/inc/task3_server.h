/***
Для решения задачи создается класс json_method,
в котором реализованы функции
    * 1. Input - считаем путь к файлу с данными в формате JSON, возвращаем эти данные в виде JSON-структуры.
    * 2. Print - выводим JSON-структуру на экран.
    * 3. Add - возвращаем JSON-структуру с добавленными данными.
    * 4. Delete - удаляем определенное поле.
    * 5. Generate - генерируем определенно заданное число данных типа string на основе заданного списка строк. 
    * 6. Execute - от существующей массива JSON заданного формата (Literature), оставим 10% книг с максимальным и минимальным рейтингом и выведем в файл output file
        Работает с JSON-массивами.
***/


#pragma once

#include <stdlib.h>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <cpp-httplib/httplib.h>
#include <nlohmann/json.hpp>

/*! @file 
 *  Здесь мы декларируем класс Literature.
 */

using namespace std;
using json = nlohmann::json;

// откуда будут читаться данные?
const char baseFilePath[] = "../data/";

/*! @class Literature
 *  Класс для хранения и работы с данными о книгах.
 */

class Literature {
 public:
       /*! @brief Конструктор загружает необходимые данные.
        * 
        *  Здесь происходит загрузка JSON-структуры из файла
        *  "generate_data.json", на основе которых загружается список 
        *  различных книг, авторов и издателей.
        */
        Literature();

        /*! @brief Загрузить JSON-структуру из файла.
         *
         *  Функция загружает из файла, в строго заданной папке,
         *  JSON-структуру и сохраняет внутри переменной класса
         *  @param[in] file_name Название файла, из которого читаем JSON-структуру.
         *  @param[out] success_status Успешность выполнения операции.
         */
        int Input(string file_name);

        /*! @brief Распечатать JSON-структуру, хранимую в классе.
         * 
         *  Функция выводит в стандартный вывод JSON-структуру, которая
         *  хранится в классе.
         *  @param[out] success_status Успешность выполнения операции.
         */
        int Print(json &data);

        /*! @brief Добавить значение в JSON-структуру, хранимую в классе, по полю Name.
         *
         *  Добавить новое единичное данное, генерируемое с полем
         *  Name на основе предоставляевом строки и с остальными полями.
         *  @param[in] name Значение поля Name, в новом данном.
         *  @param[out] success_status Успешность выполнения операции.
         */
        int Add(string name);

        /*! @brief Удалить значение из JSON-структуры, хранимой в классе, по полю Name.
         * 
         *  Удалить единичное данное из JSON-структуры, хранимой в классе, по полю Name, так как именно
         *  оно однозначно определяет данные.
         *  @param[in] field Значение поля Name в единичных данных, которые мы удалим.
         *  @param[out] success_status Успешность выполнения операции.
         */
        int Delete(string field);

        /*! @brief Сгенерировать заданное количество новых данных.
         *
         *  Сгенерировать заданное количество новых данных и перезаписать их
         *  в JSON-структуру, хранящуюся в классе. Все записанные до этого 
         *  данные исчезнут. Генерация происходит на основе заранее загруженных
         *  при создании класса данных.
         *  @param[in] entries Количество данных, которое нужно сгенерировать.
         *  @param[out] success_status Успешность выполнения операции.
         */
        int Generate(int entries);

        /*! @brief Выполнить условие задачи и вывести в файл.
         *  
         *  Выведем отсортированные данные в файл, оставив 10% книжной 
         *  продукции с максимальным и минимальным рейтингом (поле Rating).
         *  @param[in] output_file Файл, в которой выведем результат .
         *  @param[out] success_status Успешность выполнения операции.
         */
        int Execute(string output_file = "output.json");


        /*! @brief На основе данного ID, распечатать единичные данные с этим ID.
         *  
         * На вход получаем некоторое ID, корректность которого мы проверяем 
         * с помощью regex и затем, если такие данные есть в файле, то
         * распечатываеваем их в стандартный вывод.
         * @param[in] id Принятое id.
         * @param[out] success_status Успешность выполнения операции.
         */
        int GetById(string id, json &data);

        /*! @brief Обработка запросов от клиента
         *  Обработаем запросы от клиента на основе перебора возможных значений
         *  поля Command.
         *  @param[in] send Принятое от клиента сообщение.
         *  @param[out] success_status Успешность выполнения операции.
         */
        int ProcessCommand(json send, json &data);
 private:
        json data;
        vector<string> sample_authors, sample_names, sample_publishers;
        unsigned long xorshf96(void);
        int RandomNumber(int);
        json GenerateEntry();
        string GenerateId(string);
};
